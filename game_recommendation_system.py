# -*- coding: utf-8 -*-
"""game_recommendation_system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PtylLvdLT2N6B6JAGzXGLJtJMePkiSYk

# System Recommendation
by Abdulloh Umar
### Projek 2 machine learning terapan

# 0. Import libraries and modules

Dibagian ini kita import semua libraries dan modeles yang dibutuhkan
"""

from google.colab import files
import zipfile
import os
import pandas as pd
import numpy as np
from collections import Counter
from wordcloud import WordCloud
import matplotlib.pyplot as plt

from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

from sklearn.metrics import precision_score, ndcg_score

"""# 1. Load Data

### 1.1 Upload dan ekstrak dataset dari Kaggle

Pertama kita harus mengunggah credential API (file kaggle.json) ke session Colab kita.
Setelah itu kita membuat direktori .kaggle di home directory, lalu kita salin file kaggle.json (berisi API key) ke direktori .kaggle dan kita ubah permission file kaggle.json agar hanya bisa dibaca oleh pemilik. Kemuadian kita download datasetnya dari kaggle
"""

files.upload()
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download --force -d trolukovich/steam-games-complete-dataset

"""### Ekstrak file zip

Hasil unduhan yang berupa file zip kita ekstrak
"""

with zipfile.ZipFile('/content/steam-games-complete-dataset.zip', 'r') as zip_ref:
    zip_ref.extractall('steam-game-dataset')

"""### Load data ke DataFrame

Kita buka file yang sudah di ekstrak lalu kita cek 5 data awal.
"""

df = pd.read_csv('/content/steam-game-dataset/steam_games.csv')

"""# 2. Data Understanding

### Cek value 5 data pertama
Kita lihat 5 data pertama dari dataset kita untuk melihat value seperti apa yang dipakai kolomnya
"""

df.head()

"""### Cek jumlah data

Cek jumlah data disetiap kolomnya dan melihat tipe datanya
"""

df.info()

"""### Cek missing values

Kita lihat missing value pada dataset
"""

df.isnull().sum()

"""### Analisis nilai unik

Kita lihat berapa value unik (bukan duplikat) pada kolom name
"""

print('Banyak nama unik di kolom name:', len(df.name.unique()))

"""Kita cek genre apa saja yang tersedia"""

print('Banyak jenis genre unik di kolom genre:', df.genre.unique())

print('Banyak jenis genre unik di kolom genre:', len(df.genre.unique()))

"""Karena genre terlalu banyak sehingga tidak bisa ditampilkan semuanya, kita cek berapa jumlah genre yang tersedia dari jumlahnya

### Visualisasi distribusi genre dengan WordCloud

Untuk mempermudah melihat genre distribusi genre, kita menggunakan visualisasi dari `wordcloud`
"""

games_meta_data = df.copy()
games_meta_data['genre'] = games_meta_data['genre'].str.replace(',', '|') # Ganti pipeline untuk visualisasi yang lebih menarik
all_genres = games_meta_data['genre'].dropna().str.split(',') # Dihapus dulu biar NaN tidak bikin error
flat_genres = [genre.strip() for sublist in all_genres for genre in sublist]
wordcloud = WordCloud(width=2000, height=1000).generate_from_frequencies(Counter(flat_genres))

plt.figure(figsize=(15,8))
plt.imshow(wordcloud)
plt.axis("off")
plt.show()

"""# 3. Data Preparation

### Feature Selection

Dataset ini memiliki banyak kolom yang sangat komplek, namun kita hanya akan mengambil 2 diantaranya yaitu name atau judul game dan genre agar sesuai dengan tujuan proyek ini yaitu merekomendasikan game berdasarkan genre game yang dipilih sebelumnya
"""

games_meta_data = df[['name', 'genre']]
print("Shape sebelum cleaning:", games_meta_data.shape)
games_meta_data.head()

"""### Data Cleaning

#### Handling Missing Values
Menghapus baris dengan nilai NaN di kolom yang dipakai:
"""

games_meta_data = games_meta_data.dropna(subset=['name', 'genre'])

"""#### Handling Duplicate
Menghapus duplikat berdasarkan nama game:
"""

data_cleaned = games_meta_data.drop_duplicates('name')
print("Shape setelah cleaning:", data_cleaned.shape)

"""####  Normalisasi Genre
  - Mengganti pemisah koma (`,`) dengan pipe (`|`) untuk konsistensi
  - Menghapus spasi tidak perlu
"""

data_cleaned['genre'] = data_cleaned['genre'].str.replace(',', '|').str.replace(' ', '')
data_cleaned.head()

"""### Sampling data (10.000 baris)
Untuk menghemat resource, kita akan mengambil data dengan jumlah tertentu yang dinilai bisa mewakili keseluruhan. Disini kita hanya akan mengambil 10.000 data
"""

games_data = data_cleaned.sample(10000, random_state=42).reset_index(drop=True)
print("Shape final:", games_data.shape)
games_data.head()

"""### Ekstraksi Fitur dengan CountVectorizer
Mengubah data teks genre menjadi vektor numerik untuk pemrosesan model:

#### a. Tokenizer custom untuk split berdasarkan pipe ('|')
Proses ini memisahkan genre berdasarkan `|`, jadi genre yang terpisah dengan `|` akan dianggap genre yang berbeda
"""

tf = CountVectorizer(tokenizer=lambda x: x.split('|'))
count_matrix = tf.fit_transform(games_data['genre'])

"""#### b. Cek hasil
Disini kita melihat kondisi genre setelah dipisah menjadi satuan
"""

print("Contoh genre:", tf.get_feature_names_out())  # 10 genre pertama

"""#### c. Mapping Game-to-Index
membuat pemetaan antara nama game dan index-nya di DataFrame `games_data` agar mudah dan cepat menemukan indeks baris (`row index`) dari game tertentu berdasarkan namanya, saat membuat sistem rekomendasi berbasis kemiripan (`similarity`).
"""

indices = pd.Series(index=games_data['name'], data=games_data.index).drop_duplicates()

"""### Validasi Data

#### a. Cek nilai unik genre
Untuk melihat berapa jumlah genre setelah di pisah-pisah
"""

print("Jumlah genre unik:", len(tf.get_feature_names_out()))

"""#### b. Lihat contoh Game yang Tersedia
Untuk melihat game apa saja yang tersedia di 10.000 sampel yang terpilih
"""

print("Contoh 20 game acak:")
print(games_data['name'].sample(20, random_state=1).tolist())

"""#### c. Cek Distribusi Genre
Melihat genre dengan penggunaan terbanyak
"""

games_data['genre'].str.split('|').explode().value_counts().head(10).plot(kind='barh')
plt.title("Top 10 Genre")
plt.show()

"""# 4. Modeling

##  Model 1 : Content-Based Filtering (Cosine Similarity on CountVectorizer)
Model ini bertujuan untuk membuat rekomendasi berdasarkan genre game yang dipilih sebelumnya

### Hitung cosine similarity
Cosine similarity menghitung tingkat kesamaan antar game dalam bentuk angka (0-1)
"""

cosine_sim = cosine_similarity(count_matrix, count_matrix)

"""### Buat fungsi modelnya
fungsi berikut digunakan untuk membuat model yang bisa membuat rekomendasi berdasarkan genre game yang dipilih sebelumnya
"""

def get_top_n_recommendations(game_name, n=5, similarity_threshold=0.1):
    try:
        # Dapatkan index game input
        idx = indices[game_name]

        # Hitung similarity score
        sim_scores = list(enumerate(cosine_sim[idx]))

        # Urutkan dari score tertinggi
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        # Filter:
        # - Skip game itu sendiri (score=1)
        # - Hanya ambil yang melebihi threshold
        sim_scores = [
            (i, score) for i, score in sim_scores
            if i != idx and score >= similarity_threshold
        ][:n]  # Ambil Top-N

        # Format output
        recommendations = pd.DataFrame({
            'name': games_data.iloc[[i[0] for i in sim_scores]]['name'].values,
            'genre': games_data.iloc[[i[0] for i in sim_scores]]['genre'].values,
            'similarity_score': [f"{i[1]:.2f}" for i in sim_scores]
        })

        return recommendations.reset_index(drop=True)

    except KeyError:
        print(f"⚠️ Game '{game_name}' tidak ditemukan dalam database.")
        return pd.DataFrame()  # Return DataFrame kosong jika game tidak ada

"""### Cek kerja model
Disini kita lihat game apa saja yang dipilih model sebagai rekomendasi berdasarkan genre game yang dipilih sebelumnya
"""

recommendations = get_top_n_recommendations("Drawing Path", n=20)
display(recommendations)

"""## Model 2 : Popularity-Based Recommendation
Model ini bertujuan untuk membuat rekomendasi berdasarkan genre yang paling populer di dataset `games_data`

### Menghitung ke populeran suatu genre
Disini kita hitung tingkat kepopuleran suatu genre
"""

all_genres = '|'.join(games_data['genre']).split('|')
genre_counts = Counter(all_genres)
top_genres = [genre for genre, count in genre_counts.most_common(5)]

"""### Buat fungsi rekomendasinya
fungsi berikut digunakan untuk membuat model yang bisa membuat rekomendasi berdasarkan genre
"""

def get_popular_recommendations(n=20):
    # Find games containing any of the top genres
    popular_games = games_data[
        games_data['genre'].str.contains('|'.join(top_genres))
    ].copy()

    # Count how many popular genres each game has
    popular_games['matched_popular_genres'] = popular_games['genre'].apply(
        lambda x: len(set(x.split('|')) & set(top_genres))
    )

    return popular_games.sort_values(
        'matched_popular_genres',
        ascending=False
    ).head(n)[['name', 'genre', 'matched_popular_genres']]

"""### Cek kerja model
Disini kita lihat game apa saja yang dipilih model sebagai rekomendasi berdasarkan genre yang paling populer
"""

popular_rec = get_popular_recommendations()
display(popular_rec.head(10))

"""# Evaluasi Model
Disini kita hitung tingkat presisi rekomendasi

### Evaluasi Model 1
Fungsi dibawah ini dikhususkan untuk menguji skor rekomendasi dari model 1 yaitu Content-Based Filtering (Cosine Similarity on CountVectorizer)
"""

def evaluate_precision_content_based(target_game, recommended_df, k=10):
    # Ambil genre dari game target
    target_genres = set(games_data[games_data['name'] == target_game]['genre'].iloc[0].split('|'))

    # Ambil nama dari K rekomendasi teratas
    recommended_games = recommended_df['name'].head(k)

    # Hitung jumlah rekomendasi yang punya genre tumpang tindih dengan target
    match_count = 0
    for game in recommended_games:
        recommended_genres = set(games_data[games_data['name'] == game]['genre'].iloc[0].split('|'))
        if target_genres & recommended_genres:  # Cek irisan genre
            match_count += 1

    precision = match_count / k
    return precision

"""#### Tes Evaluasi
Lalu kita lihat skor evaluasinya
"""

cb_recommendation = recommendations

# Evaluasi precision@10
cb_precision = evaluate_precision_content_based("Drawing Path", cb_recommendation, k=10)
print(f'Precision@10 (Content-Based): {cb_precision:.2f}')

"""### Evaluasi Model 2
Kode dibawah ini khusus untuk mengevaluasi model 2 yaitu Popularity-Based Recommendation
"""

def evaluate_precision_popularity(top_genres, recommended_df, k=10):
    # Hitung seberapa banyak game rekomendasi mengandung genre terpopuler
    match_count = 0
    for game in recommended_df['name'].head(k):
        genres = set(games_data[games_data['name'] == game]['genre'].iloc[0].split('|'))
        if genres & set(top_genres):  # Cek apakah mengandung genre populer
            match_count += 1

    precision = match_count / k
    return precision

"""#### Tes Evaluasi
Lalu kita lihat skor evaluasinya
"""

pop_precision = evaluate_precision_popularity(top_genres, popular_rec, k=10)
print(f'Precision@10 (Popularity-Based): {pop_precision:.2f}')